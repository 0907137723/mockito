buildscript {
    repositories { mavenCentral() }
    dependencies {
        classpath "com.jcabi:jcabi-github:0.13.2"
    }
}

ext.updateReleaseNotes = { File notesFile, String toVersion ->
    println "Updating release notes file: $notesFile"
    def currentContent = notesFile.text
    def previousVersion = getPreviousVersion(notesFile)
    println "Building notes since $previousVersion until $toVersion"
    def newContent = buildNotesBetween(previousVersion, toVersion)
    notesFile.text = newContent + currentContent
    println "Successfully updated the release notes!"
}

def notesFile = project.file("doc/RELEASE-NOTES.md")
updateReleaseNotes(notesFile, "HEAD")

import com.jcabi.github.*

private String buildNotesBetween(String fromVersion, String toVersion) {
    def tickets = new HashSet()
    def commits = getCommitsBetween(fromVersion, toVersion)
    println "Parsing ${commits.size()} commits"
    commits.each {
        if (it.contains("[ci skip]")) {
            //we used #id for Travis CI build number in commits performed by Travis. Let's avoid pulling those ids here.
            //also, if ci was skipped we probably are not interested in such change, no?
            return
        }
        def t = it.findAll("#\\d+")
        if (t) {
            tickets.addAll(t*.substring(1)) //get rid of leading '#'
        }

//this is helpful to find out what Google code issues we worked on:
//        def issues = it.findAll("[Ii]ssue \\d+")
//        if (issues) {
//            println "$issues found in $it"
//        }
    }
    ImprovementSet improvements = getImprovements(tickets)
    def date = new Date().format("yyyy-MM-dd HH:mm z", TimeZone.getTimeZone("UTC"))
    return """### $project.version ($date)

* Commits: ${commits.size()}
$improvements
"""
}

class ImprovementSet {
    Collection<Improvement> improvements
    String toString() {
        if (improvements.empty) {
            return "* Improvements: 0\n"
        }
        """* Improvements: $count
  * ${improvements.join('\n  * ')}\n"""
    }
    int getCount() { improvements.size() }
}

class Improvement {
    String id
    String title
    String url
    String toString() { "$title [(#$id)]($url)" }
}

private ImprovementSet getImprovements(Set<String> tickets) {
    if (tickets.empty) {
        return new ImprovementSet(improvements: [])
    }
    println "Querying GitHub API about ${tickets.size()} tickets. This may take a while."
    def github = new RtGithub(System.env.GH_TOKEN)
    def repo = github.repos().get(new Coordinates.Simple("mockito/mockito"))
    def issues = repo.issues()
    def out = []

    tickets.each {
        println " #$it"
        def i = issues.get(it as int)
        def issue = new Issue.Smart(i)
        if (issue.exists() && !issue.isOpen()) {
            out << new Improvement(id: issue.number(), title: issue.title(), url: issue.htmlUrl())
        }
    }
    new ImprovementSet(improvements: out)
}

private String getPreviousVersion(File notesFile) {
    println "Attempting to figure out the previous version from the release notes file"
    return notesFile.withReader {
        def firstLine = it.readLine()
        assert firstLine.startsWith('###')
        //Example: "### 1.9.5 (06-10-2012)", we want to extract "1.9.5"
        def m = firstLine =~ /### (.+?) .*/
        assert m.matches()
        return m.group(1)
    }
}

private Collection<String> getCommitsBetween(String fromVersion, String toVersion) {
    println "Loading all commits between $fromVersion and $toVersion"
    def out = new ByteArrayOutputStream()
    def token = "@@commit@@"
    project.exec {
        standardOutput = out
        commandLine "git", "log", "--pretty=format:%B$token", "v${fromVersion}..v${toVersion}"
    }
    return out.toString().split(token)*.trim()
}