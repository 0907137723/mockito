buildscript {
    repositories { mavenCentral() }
    dependencies {
        classpath "com.jcabi:jcabi-github:0.13.2"
    }
}
import com.jcabi.github.*

def notesFile = project.file("doc/RELEASE-NOTES.md")
updateReleaseNotes(notesFile, "HEAD")
//println getContributionsBetween("v1.9.5", "HEAD")

private void updateReleaseNotes(File notesFile, String toVersion) {
    println "Updating release notes file: $notesFile"
    def currentContent = notesFile.text
    def previousVersion = "v" + getPreviousVersion(notesFile)
    println "Building notes since $previousVersion until $toVersion"
    def newContent = buildNotesBetween(previousVersion, toVersion)
    notesFile.text = newContent + currentContent
    println "Successfully updated the release notes!"
}

private String buildNotesBetween(String fromVersion, String toVersion) {
    def tickets = new HashSet()
    ContributionSet contributions = getContributionsBetween(fromVersion, toVersion)
    println "Parsing ${contributions.commitCount} commits"
    contributions.allCommits.each { Commit it ->
        def t = it.message.findAll("#\\d+")
        if (t) {
            tickets.addAll(t*.substring(1)) //get rid of leading '#'
        }

//this is helpful to find out what Google code issues we worked on:
//        def issues = it.findAll("[Ii]ssue \\d+")
//        if (issues) {
//            println "$issues found in $it"
//        }
    }
    ImprovementSet improvements = getImprovements(tickets)
    def date = new Date().format("yyyy-MM-dd HH:mm z", TimeZone.getTimeZone("UTC"))
    return """### $project.version ($date)

$contributions
$improvements

"""
}

class ImprovementSet {
    Collection<Improvement> improvements
    String toString() {
        if (improvements.empty) {
            return "* Improvements: 0"
        }
        """* Improvements: $count
  * ${improvements.join('\n  * ')}"""
    }
    int getCount() { improvements.size() }
}

class Improvement {
    String id
    String title
    String url
    String toString() { "$title [(#$id)]($url)" }
}

class Commit {
    String email
    String author
    String message
}

class Contribution {
    String email //identifies the contributor
    String author
    Collection<Commit> commits = new LinkedList<Commit>() //the commits
    void add(Commit commit) {
        if (email == null) {
            email = commit.email
            author = commit.author
            //TODO we could guess the best author from the ones associated with given email
            //we could base on existence of space (this hints that it's a proper first name + surname)
        }
        assert email == commit.email //email identifies the contributor, author alias not necessarily
        commits << commit
    }
    String toString() {
        "$author: ${commits.size()}"
    }
}

class ContributionSet {
    Map<String, Contribution> contributions = new HashMap<String, Contribution>()
    int commitCount //total commit count
    void add(Commit commit) {
        if (commit.message.contains("[ci skip]")) {
            //we used #id for Travis CI build number in commits performed by Travis. Let's avoid pulling those ids here.
            //also, if ci was skipped we probably are not interested in such change, no?
            //Currently, all our [ci skip] are infrastructure commits
            return
        }
        commitCount++
        def c = contributions.get(commit.email)
        if (c == null) {
            contributions.put(commit.email, c = new Contribution())
        }
        c.add(commit)
    }
    Collection<Commit> getAllCommits() {
        def out = []
        contributions.values().each {
            out.addAll(it.commits)
        }
        out
    }
    String toString() {
        def sorted = contributions.sort { a, b -> b.value.commits.size() <=> a.value.commits.size() } //top contributors first
        def grouped = sorted.groupBy { it.value.commits.size() } //groupBy number of commits
        def out = """* Authors: ${contributions.keySet().size()}
* Commits: $commitCount"""
        grouped.each { k,v ->
            out += "\n  * $k: ${v.values()*.author.join(', ')}"
        }
        out
     }
}

private ImprovementSet getImprovements(Set<String> tickets) {
    if (tickets.empty) {
        return new ImprovementSet(improvements: [])
    }
    //TODO we should query for all tickets via one REST call and stop using jcapi
    println "Querying GitHub API for ${tickets.size()} tickets. This may take a while."
    def github = new RtGithub(System.env.GH_TOKEN)
    def repo = github.repos().get(new Coordinates.Simple("mockito/mockito"))
    def issues = repo.issues()
    def out = []

    tickets.each {
        println " #$it"
        def i = issues.get(it as int)
        def issue = new Issue.Smart(i)
        if (issue.exists() && !issue.isOpen()) {
            out << new Improvement(id: issue.number(), title: issue.title(), url: issue.htmlUrl())
        }
    }
    new ImprovementSet(improvements: out)
}

private String getPreviousVersion(File notesFile) {
    println "Attempting to figure out the previous version from the release notes file"
    return notesFile.withReader {
        def firstLine = it.readLine()
        assert firstLine.startsWith('###')
        //Example: "### 1.9.5 (06-10-2012)", we want to extract "1.9.5"
        def m = firstLine =~ /### (.+?) .*/
        assert m.matches()
        return m.group(1)
    }
}

private ContributionSet getContributionsBetween(String fromVersion, String toVersion) {
    println "Loading all commits between $fromVersion and $toVersion"
    def out = new ByteArrayOutputStream()
    def entryToken = "@@commit@@"
    def infoToken = "@@info@@"
    project.exec {
        standardOutput = out
        commandLine "git", "log", "--pretty=format:%ae$infoToken%an$infoToken%B$entryToken", "${fromVersion}..${toVersion}"
    }
    def contributions = new ContributionSet()
    out.toString().split(entryToken).each { String logEntry ->
        def s = logEntry.split(infoToken)
        contributions.add(new Commit(email: s[0].trim(), author: s[1].trim(), message: s[2].trim()))
    }
    contributions
}